"""
This module has the coomon tools used by PAM Beesly's agent.
"""

import logging
import datetime
from typing import Dict, Any, List, Union
from google.adk.tools.tool_context import ToolContext
from vertexai import rag

from pam_beesly.helper import (  # pylint: disable=E0401
    get_corpus_resource_name,
    check_corpus_exists,
    _process_file_contents,
    _import_files_to_corpus,
    _perform_rag_query,
)

logger = logging.getLogger(__name__)


# <-- Tool for adding content to corpus -->
def add_content_to_corpus(
    corpus_name: str,
    content: str,
    filename: str,
    extension: str,
    tool_context: ToolContext,
) -> Dict[str, Any]:
    """
    Add content generated by the agent to the specified corpus.

    Args:
        corpus_name (str): The name of the RagCorpus resource into which to import content.
        content (str): The string content to upload to the corpus.
        filename (str): Name to use for the file. If None, a name will be generated.
        extension (str): File extension to use. If None, defaults to .txt
        tool_context (ToolContext): The tool context to use for the operation.

    Returns:
        Dict[str, Any]: The response from the data addition operation.
    """
    # Initialize result containers
    validated_paths = []
    invalid_paths = []
    uploaded_files = []

    # Set default values if None
    if filename is None:
        filename = f"uploaded_file_{int(datetime.datetime.now().timestamp())}"

    if extension is None:
        extension = ".txt"

    # Ensure extension starts with a dot
    if not extension.startswith("."):
        extension = f".{extension}"

    # Check if corpus exists
    if not check_corpus_exists(corpus_name, tool_context):
        return {
            "status": "error",
            "message": f"Corpus '{corpus_name}' does not exist.",
            "result": {},
        }

    # Always use dunder-mifflin-bucket
    gcs_bucket_name = "dunder-mifflin-bucket"

    # Create a single file content entry
    file_content_entry = {
        "content": content,
        "filename": filename,
        "extension": extension,
    }

    # Process the single file content entry
    content_result = _process_file_contents([file_content_entry], gcs_bucket_name)

    if content_result["status"] == "error":
        return {
            "status": "error",
            "message": "Failed to process file content.",
            "result": {
                "invalid_paths": content_result["invalid_paths"],
            },
        }

    validated_paths.extend(content_result["validated_paths"])
    invalid_paths.extend(content_result["invalid_paths"])
    uploaded_files.extend(content_result["uploaded_files"])

    # Ensure we have valid paths to process
    if not validated_paths:
        return {
            "status": "error",
            "message": "Failed to upload content to GCS bucket.",
            "result": {
                "invalid_paths": invalid_paths,
            },
        }

    # Import files to corpus
    import_result = _import_files_to_corpus(corpus_name, validated_paths)

    if import_result["status"] == "error":
        return {
            "status": "error",
            "message": f"Failed to add content to corpus '{corpus_name}': {import_result.get('message', '')}",
            "result": {
                "corpus_name": corpus_name,
                "corpus_resource_name": import_result.get("corpus_resource_name", ""),
                "uploaded_files": uploaded_files,
                "invalid_paths": invalid_paths,
            },
        }

    # Success case
    return {
        "status": "success",
        "message": f"Content added to corpus '{corpus_name}' successfully as '{filename}{extension}'.",
        "result": {
            "corpus_name": corpus_name,
            "corpus_resource_name": import_result["corpus_resource_name"],
            "uploaded_files": uploaded_files,
            "file_added": import_result["file_added"],
        },
    }


def rag_query(
    corpus_name: str,
    query: str,
    tool_context: ToolContext,
) -> dict:
    """
    Query a Vertex AI RAG corpus with a user question and return relevant information.

    Args:
        corpus_name (str): The name of the corpus to query. If empty, the current corpus will be used.
                          Preferably use the resource_name from list_corpora results.
        query (str): The text query to search for in the corpus
        tool_context (ToolContext): The tool context

    Returns:
        dict: The query results and status
    """
    try:
        # Check if the corpus exists
        if not check_corpus_exists(corpus_name, tool_context):
            return {
                "status": "error",
                "message": f"Corpus '{corpus_name}' does not exist. Please use one of the existing corpora: 'dunder-mifflin-docs-rag-corpus' or 'dunder-mifflin-internal-discussions-rag-corpus'.",
                "query": query,
                "corpus_name": corpus_name,
            }

        # Get the corpus resource name
        corpus_resource_name = get_corpus_resource_name(corpus_name)

        # Execute the query
        query_result = _perform_rag_query(corpus_resource_name, query)

        # Handle query execution errors
        if query_result["status"] == "error":
            return {
                "status": "error",
                "message": f"Error querying corpus: {query_result.get('message', 'Unknown error')}",
                "query": query,
                "corpus_name": corpus_name,
            }

        # Get results from successful query
        results = query_result["results"]

        # If we didn't find any results
        if not results:
            return {
                "status": "warning",
                "message": f"No results found in corpus '{corpus_name}' for query: '{query}'",
                "query": query,
                "corpus_name": corpus_name,
                "results": [],
                "results_count": 0,
            }

        # Return successful results
        return {
            "status": "success",
            "message": f"Successfully queried corpus '{corpus_name}'",
            "query": query,
            "corpus_name": corpus_name,
            "results": results,
            "results_count": len(results),
        }

    except Exception as e:
        error_msg = "Error querying corpus: {}".format(str(e))
        logger.error("Error in rag_query: %s", str(e))
        return {
            "status": "error",
            "message": error_msg,
            "query": query,
            "corpus_name": corpus_name,
        }


def get_corpus_info(
    corpus_name: str,
    tool_context: ToolContext,
) -> dict:
    """
    Get detailed information about a specific RAG corpus, including its files.

    Args:
        corpus_name (str): The full resource name of the corpus to get information about.
                           Preferably use the resource_name from list_corpora results.
        tool_context (ToolContext): The tool context

    Returns:
        dict: Information about the corpus and its files
    """
    try:
        # Check if corpus exists
        if not check_corpus_exists(corpus_name, tool_context):
            return {
                "status": "error",
                "message": f"Corpus '{corpus_name}' does not exist",
                "corpus_name": corpus_name,
            }

        # Get the corpus resource name
        corpus_resource_name = get_corpus_resource_name(corpus_name)

        # Try to get corpus details first
        corpus_display_name = corpus_name  # Default if we can't get actual display name

        # Process file information
        file_details = []
        try:
            # Get the list of files
            files = rag.list_files(corpus_resource_name)
            for rag_file in files:
                # Get document specific details
                try:
                    # Extract the file ID from the name
                    file_id = rag_file.name.split("/")[-1]

                    file_info = {
                        "file_id": file_id,
                        "display_name": (
                            rag_file.display_name
                            if hasattr(rag_file, "display_name")
                            else ""
                        ),
                        "source_uri": (
                            rag_file.source_uri
                            if hasattr(rag_file, "source_uri")
                            else ""
                        ),
                        "create_time": (
                            str(rag_file.create_time)
                            if hasattr(rag_file, "create_time")
                            else ""
                        ),
                        "update_time": (
                            str(rag_file.update_time)
                            if hasattr(rag_file, "update_time")
                            else ""
                        ),
                    }

                    file_details.append(file_info)
                except Exception:
                    # Continue to the next file
                    continue
        except Exception:
            # Continue without file details
            pass

        # Basic corpus info
        return {
            "status": "success",
            "message": f"Successfully retrieved information for corpus '{corpus_display_name}'",
            "corpus_name": corpus_name,
            "corpus_display_name": corpus_display_name,
            "file_count": len(file_details),
            "files": file_details,
        }

    except Exception as e:
        return {
            "status": "error",
            "message": f"Error getting corpus information: {str(e)}",
            "corpus_name": corpus_name,
        }


def list_corpora() -> dict:
    """
    List all available Vertex AI RAG corpora.

    Returns:
        dict: A list of available corpora and status, with each corpus containing:
            - resource_name: The full resource name to use with other tools
            - display_name: The human-readable name of the corpus
            - create_time: When the corpus was created
            - update_time: When the corpus was last updated
    """
    try:
        # Get the list of corpora
        corpora = rag.list_corpora()

        # Process corpus information into a more usable format
        corpus_info: List[Dict[str, Union[str, int]]] = []
        for corpus in corpora:
            corpus_data: Dict[str, Union[str, int]] = {
                "resource_name": corpus.name,  # Full resource name for use with other tools
                "display_name": corpus.display_name,
                "create_time": (
                    str(corpus.create_time) if hasattr(corpus, "create_time") else ""
                ),
                "update_time": (
                    str(corpus.update_time) if hasattr(corpus, "update_time") else ""
                ),
            }

            corpus_info.append(corpus_data)

        return {
            "status": "success",
            "message": f"Found {len(corpus_info)} available corpora",
            "corpora": corpus_info,
        }
    except Exception as e:
        return {
            "status": "error",
            "message": f"Error listing corpora: {str(e)}",
            "corpora": [],
        }
